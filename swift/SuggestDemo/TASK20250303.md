Elasticsearchレスポンスを適切にデコードできるようにするために、以下のステップを順に試してみてください。  
   
### 1. Swiftコードでの修正  
   
現在の問題は、Elasticsearchレスポンスデータの解析中にデコードエラーが発生していることです。以下のコードでは、このデコード処理を修正します。  
   
まず、JSONをデコードする際に、`_source`フィールドが適切にデコードされるように、カスタムデコードロジックを提供します：  
   
#### `SearchResponse` と `Post` のモデル定義を修正  
   
```swift  
// Elasticsearchレスポンスモデル  
struct SearchResponse: Decodable {  
    let hits: Hits  
      
    struct Hits: Decodable {  
        let total: Total  
        let hits: [Hit]  
          
        struct Total: Decodable {  
            let value: Int  
        }  
          
        struct Hit: Decodable {  
            let _id: String  
            let _score: Double  
            let _source: Post  
              
            private enum CodingKeys: String, CodingKey {  
                case _id, _score, _source  
            }  
              
            init(from decoder: Decoder) throws {  
                let container = try decoder.container(keyedBy: CodingKeys.self)  
                _id = try container.decode(String.self, forKey: ._id)  
                _score = try container.decode(Double.self, forKey: ._score)  
  
                // デコードのためにJSONDecoderを使用  
                let sourceContainer = try container.nestedContainer(keyedBy: Post.CodingKeys.self, forKey: ._source)  
                _source = try Post(from: sourceContainer)  
            }  
        }  
    }  
}  
   
// Postモデルの定義  
struct Post: Identifiable, Decodable {  
    let id: String  
    let postedNumber: Int  
    let createdAt: Date?  
    let postedAt: Date?  
    let postedUser: String  
    let text: String  
    let deletedAt: Date?  
    let postStatus: Int  
    let comments: [Comment]?  
  
    private enum CodingKeys: String, CodingKey {  
        case id = "PostId"  
        case postedNumber = "PostedNumber"  
        case createdAt = "CreatedAt"  
        case postedAt = "PostedAt"  
        case postedUser = "PostedUser"  
        case text = "Text"  
        case deletedAt = "DeletedAt"  
        case postStatus = "PostStatus"  
        case comments = "Comments"  
    }  
  
    init(from decoder: Decoder) throws {  
        let container = try decoder.container(keyedBy: CodingKeys.self)  
        id = try container.decode(String.self, forKey: .id)  
        postedNumber = try container.decode(Int.self, forKey: .postedNumber)  
        createdAt = try container.decodeIfPresent(Date.self, forKey: .createdAt)  
        postedAt = try container.decodeIfPresent(Date.self, forKey: .postedAt)  
        postedUser = try container.decode(String.self, forKey: .postedUser)  
        text = try container.decode(String.self, forKey: .text)  
        deletedAt = try container.decodeIfPresent(Date.self, forKey: .deletedAt)  
        postStatus = try container.decode(Int.self, forKey: .postStatus)  
        comments = try container.decodeIfPresent([Comment].self, forKey: .comments)  
    }  
}  
   
// Commentモデルの定義  
struct Comment: Identifiable, Decodable {  
    let id: String  
    let commentNumber: Int  
    let createdAt: Date?  
    let commentedAt: Date?  
    let commentedUser: String  
    let text: String  
  
    private enum CodingKeys: String, CodingKey {  
        case id = "CommentId"  
        case commentNumber = "CommentNumber"  
        case createdAt = "CreatedAt"  
        case commentedAt = "CommentedAt"  
        case commentedUser = "CommentedUser"  
        case text = "Text"  
    }  
      
    init(from decoder: Decoder) throws {  
        let container = try decoder.container(keyedBy: CodingKeys.self)  
        id = try container.decode(String.self, forKey: .id)  
        commentNumber = try container.decode(Int.self, forKey: .commentNumber)  
        createdAt = try container.decodeIfPresent(Date.self, forKey: .createdAt)  
        commentedAt = try container.decodeIfPresent(Date.self, forKey: .commentedAt)  
        commentedUser = try container.decode(String.self, forKey: .commentedUser)  
        text = try container.decode(String.self, forKey: .text)  
    }  
}  
```  
   
次に、HTTPリクエストの実行部分でのデコード処理を修正します：  
   
#### HTTPリクエスト実行の修正  
   
```swift  
// HTTPリクエスト実行の修正  
func searchPosts(query: String) -> AnyPublisher<[Post], Error> {  
    let urlString = "\(baseURL)/\(indexName)/_search"  
    guard let url = URL(string: urlString) else {  
        return Fail(error: URLError(.badURL)).eraseToAnyPublisher()  
    }  
  
    let requestBody: [String: Any] = [  
        "query": [  
            "multi_match": [  
                "query": query,  
                "fields": ["Text", "Comments.Text"],  
                "type": "best_fields",  
                "fuzziness": "AUTO"  
            ]  
        ],  
        "size": 50,  
        "_source": true  
    ]  
  
    var request = URLRequest(url: url)  
    request.httpMethod = "POST"  
    request.addValue("application/json", forHTTPHeaderField: "Content-Type")  
  
    do {  
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)  
    } catch {  
        return Fail(error: error).eraseToAnyPublisher()  
    }  
  
    return URLSession.shared.dataTaskPublisher(for: request)  
        .tryMap { result -> Data in  
            if let httpResponse = result.response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {  
                throw URLError(.badServerResponse)  
            }  
            return result.data  
        }  
        .handleEvents(receiveOutput: { data in  
            // デバッグ用にレスポンスを出力  
            print("ElasticSearch Response: \(String(data: data, encoding: .utf8) ?? "Invalid Data")")  
        })  
        .decode(type: SearchResponse.self, decoder: JSONDecoder())  
        .map { response in  
            return response.hits.hits.compactMap { $0._source }  
        }  
        .eraseToAnyPublisher()  
}  
```  
   
加えて、`JSONDecoder`をカスタマイズして、正しいデコードが行えるようにします：  
   
```swift  
// カスタムDateデコーダ設定  
extension JSONDecoder {  
    static let iso8601withFractionalSeconds: JSONDecoder = {  
        let decoder = JSONDecoder()  
        let formatter = DateFormatter()  
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSSSS"  
        formatter.locale = Locale(identifier: "en_US_POSIX")  
        formatter.timeZone = TimeZone(secondsFromGMT: 0)  
        decoder.dateDecodingStrategy = .formatted(formatter)  
        return decoder  
    }()  
}  
```  
   
### 2. Error Handlingの改善  
Swiftのデコードエラーを詳細に把握するため、デバッグ用にカスタムエラーハンドリングを追加します。  
   
```swift  
return URLSession.shared.dataTaskPublisher(for: request)  
    .tryMap { result -> Data in  
        if let httpResponse = result.response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {  
            throw URLError(.badServerResponse)  
        }  
        return result.data  
    }  
    .handleEvents(receiveOutput: { data in  
        // デバッグ用にレスポンスを出力  
        print("ElasticSearch Response: \(String(data: data, encoding: .utf8) ?? "Invalid Data")")  
    })  
    .decode(type: SearchResponse.self, decoder: JSONDecoder.iso8601withFractionalSeconds)  
    .map { response in  
        return response.hits.hits.compactMap { $0._source }  
    }  
    .catch { error -> AnyPublisher<[Post], Error> in  
        print("Decoding error: \(error)")  
        return Fail(error: error).eraseToAnyPublisher()  
    }  
    .eraseToAnyPublisher()  
```  
   
この修正で、レスポンスデータのパースエラーが解消されることを期待しています。これでも解決しない場合、レスポンスJSONの他の部分のフォーマットが問題である可能性がありますので、その場合はエラーメッセージの詳細を再度確認し、適切なデコード方法を模索する必要があります。